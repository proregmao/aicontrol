ğŸ‘Œ æ˜ç™½äº†ï¼Œæˆ‘ä¼šå¸®ä½ å†™ä¸€ä¸ª ä»£ç æ¡†æ¶ï¼Œä¸åšå®Œæ•´å®ç°ï¼Œåªç»™å‡ºæ ¸å¿ƒç»“æ„å’Œè§£æé€»è¾‘éª¨æ¶ï¼Œç¨‹åºå‘˜æ‹¿åˆ°åèƒ½ç›´æ¥å¾€é‡Œé¢å¡«å……åŠŸèƒ½ã€‚
æˆ‘å…ˆç”¨ Python ç»™å‡ºç¤ºä¾‹æ¡†æ¶ï¼ˆè·¨å¹³å°å¼€å‘å¿«ï¼Œåç»­å¯ç§»æ¤åˆ° C/C++/Go/Rustï¼‰ã€‚

â¸»

RS485-ETH-M04 åè®®è½¬æ¢ä»£ç æ¡†æ¶ï¼ˆPython ç‰ˆï¼‰

import socket
import struct
import threading
import serial
import time

# ==============================
# é…ç½®å‚æ•°ï¼ˆå¯é€šè¿‡é…ç½®æ–‡ä»¶/ç½‘é¡µä¼ å…¥ï¼‰
# ==============================
CONFIG = {
    "ip": "192.168.1.12",
    "tcp_ports": [502, 503, 504, 505, 5502, 8801, 8802, 8803, 8804],
    "serial_ports": {
        "ch0": "/dev/ttyUSB0",
        "ch1": "/dev/ttyUSB1",
    },
    "baudrate": 9600,
    "bytesize": 8,
    "parity": "N",
    "stopbits": 1,
    "mode": "MODBUS_TCP_TO_RTU_COMMON",  # å¯é€‰æ¨¡å¼
}

# ==============================
# å·¥å…·å‡½æ•°
# ==============================

def calc_crc(data: bytes) -> bytes:
    """è®¡ç®— MODBUS RTU CRC16"""
    crc = 0xFFFF
    for ch in data:
        crc ^= ch
        for _ in range(8):
            if crc & 1:
                crc >>= 1
                crc ^= 0xA001
            else:
                crc >>= 1
    return struct.pack("<H", crc)

def tcp_to_rtu(tcp_data: bytes) -> bytes:
    """TCP æŠ¥æ–‡ â†’ RTU æŠ¥æ–‡"""
    # TCP æŠ¥æ–‡å¤´: [Transaction ID(2), Protocol ID(2), Length(2), Unit ID(1)]
    if len(tcp_data) < 8:
        return b""
    unit_id = tcp_data[6]
    pdu = tcp_data[7:]  # åŠŸèƒ½ç  + æ•°æ®
    rtu_data = bytes([unit_id]) + pdu + calc_crc(bytes([unit_id]) + pdu)
    return rtu_data

def rtu_to_tcp(rtu_data: bytes, transaction_id=1) -> bytes:
    """RTU æŠ¥æ–‡ â†’ TCP æŠ¥æ–‡"""
    if len(rtu_data) < 5:  # æœ€å°é•¿åº¦ï¼šAddr+Func+Data+CRC
        return b""
    unit_id = rtu_data[0]
    pdu = rtu_data[1:-2]  # å»æ‰ CRC
    length = len(pdu) + 1  # Unit ID + PDU
    header = struct.pack(">HHHB", transaction_id, 0, length, unit_id)
    return header + pdu

# ==============================
# é€šè®¯ç±»
# ==============================

class ModbusGateway:
    def __init__(self):
        # æ‰“å¼€ä¸²å£
        self.ser = serial.Serial(
            CONFIG["serial_ports"]["ch0"],
            baudrate=CONFIG["baudrate"],
            bytesize=CONFIG["bytesize"],
            parity=CONFIG["parity"],
            stopbits=CONFIG["stopbits"],
            timeout=1,
        )

    def handle_tcp_client(self, conn, addr):
        print(f"[TCP] Client connected: {addr}")
        try:
            while True:
                data = conn.recv(1024)
                if not data:
                    break

                if CONFIG["mode"] == "MODBUS_TCP_TO_RTU_COMMON":
                    rtu_req = tcp_to_rtu(data)
                    print(f"[DEBUG] TCPâ†’RTU: {rtu_req.hex()}")
                    self.ser.write(rtu_req)
                    rtu_resp = self.ser.read(256)
                    if rtu_resp:
                        tcp_resp = rtu_to_tcp(rtu_resp)
                        conn.sendall(tcp_resp)

                elif CONFIG["mode"] == "SERVER_TRANSPARENT":
                    # ç›´æ¥é€ä¼ 
                    self.ser.write(data)
                    resp = self.ser.read(256)
                    if resp:
                        conn.sendall(resp)

                # å…¶ä»–æ¨¡å¼å¯åœ¨æ­¤æ‰©å±•

        except Exception as e:
            print(f"[ERROR] {e}")
        finally:
            conn.close()

    def start_tcp_server(self, port):
        srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        srv.bind((CONFIG["ip"], port))
        srv.listen(5)
        print(f"[TCP] Listening on {CONFIG['ip']}:{port}")
        while True:
            conn, addr = srv.accept()
            threading.Thread(target=self.handle_tcp_client, args=(conn, addr)).start()

    def run(self):
        for port in CONFIG["tcp_ports"]:
            threading.Thread(target=self.start_tcp_server, args=(port,), daemon=True).start()

        while True:
            time.sleep(1)


if __name__ == "__main__":
    gateway = ModbusGateway()
    gateway.run()


â¸»

è¯´æ˜
	1.	æ¨¡å¼åˆ‡æ¢ï¼šé€šè¿‡ CONFIG["mode"] é€‰æ‹©åŠŸèƒ½æ¨¡å¼ï¼ˆå¦‚ MODBUS_TCP_TO_RTU_COMMON / SERVER_TRANSPARENT ç­‰ï¼‰ã€‚
	2.	TCP â†” RTU è½¬æ¢ï¼štcp_to_rtu / rtu_to_tcp å°è£…äº†è§£æé€»è¾‘ã€‚
	3.	é€ä¼ æ¨¡å¼ï¼šä¿ç•™äº† SERVER_TRANSPARENT æ¡†æ¶ï¼Œç›´æ¥æŠŠ TCP æ•°æ®å†™ä¸²å£ã€ä¸²å£æ•°æ®å†™ TCPã€‚
	4.	å¿ƒè·³åŒ…ã€è‡ªå®šä¹‰æŠ¥æ–‡å¤´å°¾ï¼šå¯ä»¥åœ¨ handle_tcp_client é‡ŒåŠ ä¸Šå®šæ—¶å‘é€é€»è¾‘ã€‚
	5.	å¤šç«¯å£ç›‘å¬ï¼šä¼šåŒæ—¶ç›‘å¬ 502505, 5502, 88018804ï¼Œæ¨¡æ‹Ÿè®¾å¤‡å¤šé€šé“ã€‚

â¸»

å¥½ï¼Œé‚£æˆ‘å¸®ä½ å†™ä¸€ä¸ª Linux ä¸‹å¯ç”¨çš„ C++ ä»£ç æ¡†æ¶ï¼Œç›´æ¥è·‘åœ¨ Ubuntu ç­‰ç³»ç»Ÿä¸Šï¼Œä½œä¸º RS485-ETH-M04 åè®®ç½‘å…³çš„åŸºç¡€å®ç°ã€‚

â¸»

RS485-ETH-M04 åè®®è½¬æ¢ä»£ç æ¡†æ¶ï¼ˆC++ / Linuxï¼‰

ä¾èµ–ï¼š
	â€¢	ä¸²å£ï¼šç”¨ <termios.h> æ§åˆ¶ /dev/ttyUSBx
	â€¢	TCP Socketï¼šç”¨ <sys/socket.h>ã€<netinet/in.h>

ä¸‹é¢æ˜¯æœ€å°å¯è¿è¡Œéª¨æ¶ï¼š

#include <iostream>
#include <thread>
#include <vector>
#include <string>
#include <cstring>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#include <arpa/inet.h>
#include <sys/socket.h>

// ============================
// é…ç½®
// ============================
struct Config {
    std::string ip = "0.0.0.0";   // ç›‘å¬æœ¬æœº
    int ports[5] = {502, 503, 504, 505, 5502};
    std::string serial_dev = "/dev/ttyUSB0";
    int baudrate = B9600;
} CONFIG;

// ============================
// å·¥å…·å‡½æ•°
// ============================

// CRC16 (Modbus)
uint16_t calc_crc(const uint8_t *data, int len) {
    uint16_t crc = 0xFFFF;
    for (int i = 0; i < len; i++) {
        crc ^= data[i];
        for (int j = 0; j < 8; j++) {
            if (crc & 1) {
                crc >>= 1;
                crc ^= 0xA001;
            } else {
                crc >>= 1;
            }
        }
    }
    return crc;
}

// æ‰“å¼€ä¸²å£
int open_serial(const std::string &dev, int baudrate) {
    int fd = open(dev.c_str(), O_RDWR | O_NOCTTY | O_SYNC);
    if (fd < 0) {
        perror("open serial");
        return -1;
    }
    struct termios tty{};
    if (tcgetattr(fd, &tty) != 0) {
        perror("tcgetattr");
        close(fd);
        return -1;
    }

    cfsetospeed(&tty, baudrate);
    cfsetispeed(&tty, baudrate);

    tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8;     // 8 æ•°æ®ä½
    tty.c_cflag &= ~PARENB;                         // æ— æ ¡éªŒ
    tty.c_cflag &= ~CSTOPB;                         // 1 åœæ­¢ä½
    tty.c_cflag |= CLOCAL | CREAD;

    tty.c_iflag = 0;
    tty.c_oflag = 0;
    tty.c_lflag = 0;

    tty.c_cc[VMIN] = 0;
    tty.c_cc[VTIME] = 10;

    if (tcsetattr(fd, TCSANOW, &tty) != 0) {
        perror("tcsetattr");
        close(fd);
        return -1;
    }
    return fd;
}

// ============================
// TCP â†” RTU è½¬æ¢ç¤ºä¾‹
// ============================

std::vector<uint8_t> tcp_to_rtu(const std::vector<uint8_t> &tcp) {
    if (tcp.size() < 8) return {};
    uint8_t unit_id = tcp[6];
    std::vector<uint8_t> pdu(tcp.begin() + 7, tcp.end());
    std::vector<uint8_t> rtu;
    rtu.push_back(unit_id);
    rtu.insert(rtu.end(), pdu.begin(), pdu.end());
    uint16_t crc = calc_crc(rtu.data(), rtu.size());
    rtu.push_back(crc & 0xFF);
    rtu.push_back(crc >> 8);
    return rtu;
}

std::vector<uint8_t> rtu_to_tcp(const std::vector<uint8_t> &rtu, uint16_t trans_id = 1) {
    if (rtu.size() < 5) return {};
    uint8_t unit_id = rtu[0];
    std::vector<uint8_t> pdu(rtu.begin() + 1, rtu.end() - 2); // å»æ‰ CRC
    uint16_t length = pdu.size() + 1;

    std::vector<uint8_t> tcp;
    tcp.push_back(trans_id >> 8);
    tcp.push_back(trans_id & 0xFF);
    tcp.push_back(0x00); tcp.push_back(0x00); // Protocol ID
    tcp.push_back(length >> 8);
    tcp.push_back(length & 0xFF);
    tcp.push_back(unit_id);
    tcp.insert(tcp.end(), pdu.begin(), pdu.end());
    return tcp;
}

// ============================
// TCP æœåŠ¡çº¿ç¨‹
// ============================

void handle_client(int client_fd, int serial_fd) {
    uint8_t buf[1024];
    while (true) {
        int n = recv(client_fd, buf, sizeof(buf), 0);
        if (n <= 0) break;

        std::vector<uint8_t> tcp(buf, buf + n);
        auto rtu_req = tcp_to_rtu(tcp);
        if (!rtu_req.empty()) {
            write(serial_fd, rtu_req.data(), rtu_req.size());
            std::cout << "[TCPâ†’RTU] " << rtu_req.size() << " bytes" << std::endl;
        }

        // ç­‰å¾…ä¸²å£å“åº”
        int m = read(serial_fd, buf, sizeof(buf));
        if (m > 0) {
            std::vector<uint8_t> rtu(buf, buf + m);
            auto tcp_resp = rtu_to_tcp(rtu);
            if (!tcp_resp.empty()) {
                send(client_fd, tcp_resp.data(), tcp_resp.size(), 0);
                std::cout << "[RTUâ†’TCP] " << tcp_resp.size() << " bytes" << std::endl;
            }
        }
    }
    close(client_fd);
}

void start_tcp_server(int port, int serial_fd) {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(port);

    bind(server_fd, (sockaddr*)&addr, sizeof(addr));
    listen(server_fd, 5);
    std::cout << "[TCP] Listening on port " << port << std::endl;

    while (true) {
        int client_fd = accept(server_fd, nullptr, nullptr);
        std::thread(handle_client, client_fd, serial_fd).detach();
    }
}

// ============================
// ä¸»ç¨‹åº
// ============================

int main() {
    int serial_fd = open_serial(CONFIG.serial_dev, CONFIG.baudrate);
    if (serial_fd < 0) return 1;

    std::vector<std::thread> threads;
    for (int port : CONFIG.ports) {
        threads.emplace_back(start_tcp_server, port, serial_fd);
    }

    for (auto &t : threads) t.join();
    return 0;
}


â¸»

åŠŸèƒ½è¯´æ˜
	1.	ä¸²å£åˆå§‹åŒ–ï¼šopen_serial æ‰“å¼€ /dev/ttyUSB0ï¼Œé…ç½®ä¸º 9600 8N1ã€‚
	2.	TCP ç›‘å¬ï¼šåŒæ—¶ç›‘å¬ 502ã€503ã€504ã€505ã€5502 äº”ä¸ªç«¯å£ï¼ˆå¯æ‰©å±•åˆ° 8801~8804ï¼‰ã€‚
	3.	æ•°æ®æµï¼š
	â€¢	TCP â†’ RTUï¼štcp_to_rtu() è´Ÿè´£åŠ  CRC16 å¹¶è½¬å‘åˆ°ä¸²å£ã€‚
	â€¢	RTU â†’ TCPï¼šrtu_to_tcp() è´Ÿè´£åŠ ä¸Š Modbus TCP æŠ¥æ–‡å¤´ã€‚
	4.	å¤šçº¿ç¨‹ï¼šæ¯ä¸ª TCP å®¢æˆ·ç«¯å•ç‹¬çº¿ç¨‹å¤„ç†ï¼Œæ”¯æŒå¹¶å‘ã€‚

â¸»

ä¸‹ä¸€æ­¥æ‰©å±•
	â€¢	å¢åŠ  Server é€ä¼  / Client é€ä¼  / è‡ªå®šä¹‰æŠ¥æ–‡å¤´å°¾ / å¿ƒè·³åŒ… æ¨¡å¼åˆ‡æ¢
	â€¢	å¢åŠ  é…ç½®æ–‡ä»¶è§£æï¼ˆJSON/YAMLï¼‰æ¥åˆ‡æ¢æ¨¡å¼å’Œå‚æ•°
	â€¢	å¢åŠ  æ—¥å¿—ä¸è°ƒè¯•ï¼ˆä¿å­˜ hex æµï¼‰

